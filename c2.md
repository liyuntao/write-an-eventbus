在上一章节，我们简要介绍了Guava类库中EventBus的功能，并以一个demo展示了其主要用法。接下来我们尝试自己实现一个EventBus，并在这个过程中理解Guava/EventBus的设计与实现。

## 核心API定义

首先根据demo的用法，需要至少三个方法来实现一个基本的EventBus功能。方法声明如下，实现暂时留空：
```java
public class EventBus {

    /**
     * 将object对象上所有订阅方法注册至eventbus
     * 
     * @param object
     */
    public void register(Object object) {}

    /**
     * 将object对象上所有的订阅方法注销
     *
     * @param object
     */
    public void unregister(Object object) {}

    /**
     * 将event发送至所有的订阅者
     *
     * @param event
     */
    public void post(Object event) {}
}
```

## API实现分析

1. 按照上述定义，`register()`方法用于将订阅者对象的方法注册至EventBus当中。所以EventBus对象当中需要保存这个订阅者对象，同时查找出此对象中所有被注解标注的订阅方法。这里订阅者对象和其上的所有方法具有一对多的K-V的关系，需要用到`Map<Object, List<Method>>`这样一个集合类。
2. 与`register()`相反，`unregister()`方法用于反注册(注销)目标对象。调用unregister后，需要清除集合类中的订阅者对象，还有与其相关的这些方法。
3. `post()`方法用于发送事件对象给订阅者。所以这里的逻辑主要是通过上述在register后形成的集合类里，由post入参event的实际类型，找出所有符合的Methods，最终通过反射一一调用之。


## 创建注解

EventBus使用一个注解来标记订阅方法，所以我们需要创建这样一个注解：
* 注解用于标记订阅方法，所以它作用于方法上
* register方法在运行期会查找被注解的方法，所以该注解需要保留到运行时
* 
```java
@Retention(RetentionPolicy.RUNTIME) // 保留策略：将这个注解保留到运行时
@Target(ElementType.METHOD) // 作用目标：注解适用于方法
public @interface Subscribe {
}
```